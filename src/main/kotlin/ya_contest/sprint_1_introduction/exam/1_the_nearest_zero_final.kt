package ya_contest.sprint_1_introduction.exam

import kotlin.math.abs

/**
 * Условие:
 * Тимофей ищет место, чтобы построить себе дом. Улица, на которой он хочет жить, имеет длину n, то есть состоит из n одинаковых идущих подряд участков.
 * Каждый участок либо пустой, либо на нём уже построен дом.
 * Общительный Тимофей не хочет жить далеко от других людей на этой улице. Поэтому ему важно для каждого участка знать расстояние до ближайшего пустого участка.
 * Если участок пустой, эта величина будет равна нулю — расстояние до самого себя.
 * Помогите Тимофею посчитать искомые расстояния. Для этого у вас есть карта улицы.
 * Дома в городе Тимофея нумеровались в том порядке, в котором строились, поэтому их номера на карте никак не упорядочены.
 * Пустые участки обозначены нулями.
 *
 * Формат ввода:
 * В первой строке дана длина улицы —– n (1 ≤ n ≤ 10ˆ6). В следующей строке записаны n целых неотрицательных чисел — номера домов и обозначения пустых участков на карте (нули). Гарантируется, что в последовательности есть хотя бы один ноль.
 * Номера домов (положительные числа) уникальны и не превосходят 10ˆ9.
 *
 * Формат вывода:
 * Для каждого из участков выведите расстояние до ближайшего нуля. Числа выводите в одну строку, разделяя их пробелами.
 *
 * Ограничение:
 * Ограничение времени - 1 секунда
 * Ограничение памяти - 64Mb
 * Ввод	стандартный ввод или input.txt
 * Вывод стандартный вывод или output.txt
 *
 * Пример 1:
 * Ввод
 * 5
 * 0 1 4 9 0
 * Вывод
 * 0 1 2 1 0
 *
 * Пример 2:
 * Ввод
 * 6
 * 0 7 9 4 8 20
 * Вывод
 * 0 1 2 3 4 5
 */

private fun main() {
    val n = readln().toInt()
    val street = readln().split(" ").map { it.toInt() }
    println(countNearestZero(n,street).joinToString(" "))
}

private fun countNearestZero(size: Int, street: List<Int>): List<Int> {
    val result = IntArray(size) { size }
    var nearestZero = -1
    for (i in 0 until size) {
        if(street[i] == 0) {
            nearestZero = i
        }
        if (nearestZero != -1) {
            result[i] = i - nearestZero
        }
    }
    nearestZero = -1
    for (i in size - 1 downTo 0) {
        if(street[i] == 0) {
            nearestZero = i
        }
        if (nearestZero != -1) {
            result[i] = minOf(nearestZero - i, result[i])
        }
    }
    return result.toList()
}
### AVL-Tree

AVL-Tree - это бинарное дерево поиска, для которого выполняется следующий инвариант,
для каждой вершины x, разница между левым и правым поддеревом отличается не больше чем 1

`
| h(left) - h(right) | >= 1 (1)
`

Знак выражения показывает, какое дерево перевешивает.
Если знак "минус", то перевешивает правое поддерево, иначе левое поддерево.
Таким образом, валидный набор значений для неравенства (1) следующий: 0, -1, 1.
Это не равенство может быть нарушено только во время вставки нового элемента или удаления старого элемента из AVL
дерева.
Значит невалидные значения будут следующими: -2, 2. Никаких других значений быть не может. Для восстановления
инварианта, будем
балансировать дерево. Балансировка - это операция, которая изменяет отношения предок-потомок в вершине для заданного
поддерева, чтобы
инвариант (1) сохранялся.
Таким образом, для балансировки дерева будем хранить разницу высот между левым и правым поддеревом `diff[i]=h(L)−h(R)`

Для балансировки AVL дерева применяются операции поворота. Существует 4 вида поворота

1) LL-поворот
2) RR-поворот
3) LR-поворот
4) RL-поворот

Рассмотрим только LL-поворот и RL-поворот, остальные операции поворотов будут симметричными.

#### LL-поворот(Малое левое вращение)

| Тип вращения         | Иллюстрация                                                                                                          | Когда используется                                           | Расстановка балансов                                       |
|----------------------|----------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------|------------------------------------------------------------|
| Малое левое вращение | ![](/Users/samarbaeffruslan/Projects/IdeaProjects/algo_data_study/src/main/resources/images/tree/common_ll_turn.png) | `diff[a] = -2, diff[b] = -1` или `diff[a] = -2, diff[b] = 0` | `diff[a] = 0, diff[b] = 0` или `diff[a] = -1, diff[b] = 1` |

#### RL-поворот(Большое левое вращение)

| Тип вращения           | Иллюстрация                                                                                                          | Когда используется                                                                                                      | Расстановка балансов                                                                                         |
|------------------------|----------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------|
| Большое левое вращение | ![](/Users/samarbaeffruslan/Projects/IdeaProjects/algo_data_study/src/main/resources/images/tree/common_rl_turn.png) | `diff[a]=−2 , diff[b]=1 и diff[c]=1` или `diff[a]=−2 , diff[b]=1 и diff[c]=−1` или `diff[a]=−2 , diff[b]=1 и diff[c]=0` | `diff[a]=0 , diff[b]=−1 и diff[c]=0` `diff[a]=1 , diff[b]=0 и diff[c]=0` `diff[a]=0 , diff[b]=0 и diff[c]=0` |

#### Вставка элемента в AVL-дерево
Рекурсивно спускаемся в дерево до тех пор, пока не найдем пустое место, куда можно вставить элемент.
При выходе из рекурсии восстанавливаем свойство avl-дерева.

#### Удаление элемента из AVL-дерево
Находим узел с заданным ключом k, в правом поддереве находим узел с наименьшим ключом и заменяем удаляемый узел на найденный узел.
При выходе из рекурсии восстанавливаем свойство avl-дерева.

#### Поиск элемента в AVL-дереве
Алгоритм такой же, как и у наивной реализации BST